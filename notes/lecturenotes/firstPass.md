Algorithmic problems are everywhere, in literally every domain of computer science / software development. Students need to get comfortable solving these sorts of problems, both for technical interviews, as well as for handling the day-to-day workload that is expected of software developers.

In this module, students are going to be learning about how to approach and tackle algorithmic problems. This sprint will introduce students to a few useful paradigms that can be used to approach and improve algorithm problems.

At the end of this module, you should be able to:
approach a novel problem and come up with a workable first-pass solution.
define what runtime complexity is, differentiate between various classifications and categorize the performance of an algorithm using Big O notation

Oftentimes the first step to tackling an algorithmic problem we haven’t encountered before is to get something working, regardless of whether or not it’s working badly, and then improve and iterate upon our initial working solution. This is a skill that must be practiced and honed, but as students get more practice doing this, then, when they encounter a problem they’ve seen before, they’re often able to skip directly to implementing the improved solution right off the bat.

Algorithms aren’t just ready-made solutions - they’re a way of thinking. Learning to approach a problem with both a rigorous and efficient mindset, and when to use what common “tricks”, is a core skill for software development. Typically, when it comes to tackling a novel problem, the first thing to do is to come with any solution that works.

One strategy for approaching novel problems is to use Polya’s Problem Solving Techniques. Let’s break down each step a bit further and outline some things we can do to complete each step.